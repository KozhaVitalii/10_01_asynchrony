{"version":3,"sources":["js/06-timer.js"],"names":["pad","value","String","padStart","getTimeComponents","time","hours","Math","floor","mins","secs","refs","startBtn","document","querySelector","stopBtn","clockface","Timer","onTick","intervalId","isActive","init","startTime","Date","now","setInterval","currentTime","deltaTime","clearInterval","timer","updateClockface","textContent","addEventListener","start","bind","stop"],"mappings":";;;AAycA,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAtZE,SAASA,EAAIC,GACJC,OAAAA,OAAOD,GAAOE,SAAS,EAAG,KAInC,SAAUC,EAAkBC,GAKnB,MAAA,CAAEC,MAJKN,EAAIO,KAAKC,MAAOH,EAAQ,MAAyB,OAI/CI,KAHHT,EAAIO,KAAKC,MAAOH,EAAQ,KAAoB,MAGnCK,KAFTV,EAAIO,KAAKC,MAAOH,EAAQ,IAAc,OA3DvD,QAAA,qBA8EA,IAAMM,EAAO,CACXC,SAAUC,SAASC,cAAc,6BACjCC,QAASF,SAASC,cAAc,4BAChCE,UAAWH,SAASC,cAAc,kBAiJ9BG,EAAAA,WACoB,SAAA,EAAA,GAAVC,IAAAA,EAAAA,EAAAA,OAAU,EAAA,KAAA,GACjBC,KAAAA,WAAa,KACbC,KAAAA,UAAW,EACXF,KAAAA,OAASA,EAETG,KAAAA,OAiOT,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OA7NS,MAAA,WACChB,IAAAA,EAAO,KAAKD,kBAAkB,GAC/Bc,KAAAA,OAAOb,KA2NhB,CAAA,IAAA,QAxNU,MAAA,WAAA,IAAA,EAAA,KACF,IAAA,KAAKe,SAAL,CAIEE,IAAAA,EAAYC,KAAKC,MAClBJ,KAAAA,UAAW,EAEXD,KAAAA,WAAaM,YAAY,WACtBC,IACAC,EADcJ,KAAKC,MACOF,EAC1BjB,EAAO,EAAKD,kBAAkBuB,GAEpC,EAAKT,OAAOb,IACX,QA0MP,CAAA,IAAA,OAvMS,MAAA,WACLuB,cAAc,KAAKT,YACdC,KAAAA,UAAW,EAEVf,IAAAA,EAAO,KAAKD,kBAAkB,GAC/Bc,KAAAA,OAAOb,KAkMhB,CAAA,IAAA,oBA3LoBA,MAAAA,SAAAA,GAOT,MAAA,CAAEC,MANK,KAAKN,IACjBO,KAAKC,MAAOH,EAAQ,MAAyB,OAK/BI,KAHH,KAAKT,IAAIO,KAAKC,MAAOH,EAAQ,KAAoB,MAGxCK,KAFT,KAAKV,IAAIO,KAAKC,MAAOH,EAAQ,IAAc,SAsL5D,CAAA,IAAA,MAhLMJ,MAAAA,SAAAA,GACKC,OAAAA,OAAOD,GAAOE,SAAS,EAAG,SA+KrC,EAvOMc,GA4DAY,EAAQ,IAAIZ,EAAM,CAEtBC,OAAQY,IAWV,SAASA,EAAuC,GAArBxB,IAAAA,EAAAA,EAAAA,MAAOG,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,KACtCC,EAAKK,UAAUe,YAAiBzB,GAAAA,OAAAA,EAASG,KAAAA,OAAAA,EAAQC,KAAAA,OAAAA,GAJnDC,EAAKC,SAASoB,iBAAiB,QAASH,EAAMI,MAAMC,KAAKL,IACzDlB,EAAKI,QAAQiB,iBAAiB,QAASH,EAAMM,KAAKD,KAAKL","file":"06-timer.fdf34921.js","sourceRoot":"../src","sourcesContent":["import '../css/common.css';\n\n// Задача: напишем таймер с кнопкой старт при нажатии на которую начинается отсчёт и стоп при нажатии\n// на которую время останавливается.\n\n// Создадим объект (секундомер с двумя кнопками старт и стоп)\n// const timer = {\n//   start() {\n//     const startTime = Date.now(); // создадим локальную переменную в которой будем хранить начальное время.\n// // Также во время вызова start() запустим интервал, который будет вызывать какую то функцию каждую секунду: \n//     setInterval(() => {\n//   // console.log('startTime :', startTime); // при этом startTime при этом не меняется т.к. была создана во время вызова функции старт start(), а не setInterval()\n//   // console.log('Вывожу сообщение каждую секунду');\n// //  Далее, мы внутри этой функции можем получать текущее время на момент вызова этой отложенной функции:\n//     const currentTime = Date.now(); \n//   // console.log('startTime :', currentTime); // получаем текущее время\n// //  Теперь возьмем и отнимем от текущего времени currentTime время старта startTime нашего секундомера:\n//     // console.log(currentTime - startTime);\n// // Запишем эту разницу в виде переменной: \n//     const deltaTime = currentTime - startTime;\n//   //  А так же создадим переменную в которой будем преобразовывать полученный в deltaTime результат в привычный формат времени:    \n//       // const timeComponents = getTimeComponents(deltaTime);\n//       // console.log(timeComponents); // получим такой результат\n//       // console.log('HH:MM:SS'); // а нам необходимо получять время в таком формате, поэтому нам необходимо нашу функцию getTimeComponents расширить, \n//       // обернув её в функцию pad \n//       // Деструктуризаруем наш timeComponents, т.к. сама функция возвращает return { hours, mins, secs }: и теперь вместо const timeComponents = \n//       // getTimeComponents(deltaTime); запишем так:\n//       const { hours, mins, secs } = getTimeComponents(deltaTime); // и подставим значение в наш формат(шаблон) console.log('HH:MM:SS'):\n//       console.log(`${hours}:${mins}:${secs}`);\n\n//       // или так:\n//       // console.log(`${pad(new Date(deltaTime).getUTCHours())}:${pad(\n//       // new Date(deltaTime).getUTCMinutes())}:${pad(new Date(deltaTime).getUTCSeconds())}`); // но проблема такого подхода в том, что если нам к примеру\n//       // необходимо запустить акцию по распродаже на 2 суток 12 часов 40 минут и 10 секунд, все хорошо до тех пор пока нам не понадобиться вытащить сутки, а\n//       // через такой подход получить сутки возможности нет, а кол-во часов ограничено 24 часами (т.е. вывести к примеру 60 часов или 72 не получится).\n//       // А через формулы Индуса можно посчитать дни, сутки, недели, месяцы и т.д.\n\n//     }, 1000);\n//   },\n// };\n\n//  Необходимо написать функцию которая будет полученный результат преобразовать в нормальный формат времени:\n  // function  getTimeComponents(time) {\n  //   const hours = Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n  //   const mins = Math.floor((time % (1000 * 60 * 60)) / (1000 * 60));\n  //   const secs = Math.floor((time % (1000 * 60)) / 1000);\n\n  //   return { hours, mins, secs };\n  // }\n\n  // Функция pad принимает число, приводит к строке и добавляет в начало 0 если число меньше 2-х знаков, если два знака то ничего не делает:\n  function pad(value) {\n    return String(value).padStart(2, '0');\n  }\n\n// дополним нашу функцию getTimeComponents функцией pad, можем расширить (дополнив сутками, днями, неделями):\n  function  getTimeComponents(time) {\n    const hours = pad(Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)));\n    const mins = pad(Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)));\n    const secs = pad(Math.floor((time % (1000 * 60)) / 1000));\n\n    return { hours, mins, secs };\n  }\n\n// timer.start() // во время вызова этого метода, создается переменная startTime в которой хранится начальное время.\n\n// Ок со временем разобрались, теперь необходимо реализовать интерфейс для пользователя (разметку):\n\n    // <div class=\"timer\">\n    //   <p class=\"clockface js-clockface\"></p> // это условное табло, куда мы будем выводить наше время т.е. deltaTime\n\n    //   <div class=\"actions\">\n    //     <button class=\"timer-btn\" data-action-start>Запустить</button> // кнопка запустить таймер\n    //     <button class=\"timer-btn\" data-action-stop>Остановить</button> // кнопка остановить таймер\n    //   </div>\n    // </div>\n   \n// Настроим связи с разметкой:\nconst refs = {\n  startBtn: document.querySelector('button[data-action-start]'),\n  stopBtn: document.querySelector('button[data-action-stop]'),\n  clockface: document.querySelector('.js-clockface'),\n};\n\n// Повесим слушатели событий на наши кнопки, где заинлайним функцию:\n// refs.startBtn.addEventListener('click', () => { timer.start() }); // слушатель событий с фунцкцией для запуска таймера \n// refs.stopBtn.addEventListener('click', () => { timer.stop() }); // слушатель событий с фунцкцией для остановки таймера\n\n// если хотим передавать колбеком то нашему timer необходимо привязать контекст через .bind(timer):\n// refs.startBtn.addEventListener('click', timer.start.bind(timer));\n// refs.stopBtn.addEventListener('click', timer.stop.bind(timer));\n\n// Необходимо реализоваь функцию которая остановит интервал, дополним нашу запись функцией стоп:\n// const timer = {\n//   intervalId: null,\n//   start() {\n//     const startTime = Date.now();\n    \n//       this.intervalId = setInterval(() => {\n//         const currentTime = Date.now();\n//         const deltaTime = currentTime - startTime;\n//         const { hours, mins, secs } = getTimeComponents(deltaTime);\n\n//       console.log(`${hours}:${mins}:${secs}`);\n//     }, 1000);\n//   },\n//   stop() {\n//     clearInterval(this.intervalId);\n//   }\n// };\n\n// timer.start() // во время вызова этого метода, создается переменная startTime в которой хранится начальное время.\n\n// Проблема при такой реализации заключается в том, что если мы повторно нажмем на кнопку старт, то у нас запустить новый интервал, если несколько раз\n// нажмем на старт, то запустится несколько интервалов.Нажав на кнопку стоп, мы остановим лишь один интервал а остальные будут скопом вести отсчёт, поэтому\n// необходимо хранить состояние нашего интервала, и если он активный, потоврное нажатие ни к чему не приведёт. Дополним нашу запись доп. переменной\n// isActive, которая по умолчанию будет false, а также дополним нашу функцию start условие с проверкой активный или нет:\n\n// const timer = {\n//   intervalId: null,\n//   isActive: false, // состояние по умолчанию\n//   start() {\n//     if (this.isActive) {\n//       return;\n//     }\n//     const startTime = Date.now();\n//     this.isActive = true; // если наш isActive в условии if не активный, то присваиваем активный и запускаем интервал\n\n//       this.intervalId = setInterval(() => {\n//         const currentTime = Date.now(); \n//         const deltaTime = currentTime - startTime;\n//         const { hours, mins, secs } = getTimeComponents(deltaTime);\n\n//       console.log(`${hours}:${mins}:${secs}`);\n//     }, 1000);\n//   },\n//   stop() {\n//     clearInterval(this.intervalId);\n//     this.isActive = false;\n//   }\n// };\n\n// timer.start() // во время вызова этого метода, создается переменная startTime в которой хранится начальное время.\n\n// Теперь необходимо нарисовать интерфейс.У нас есть метод updateClockface, который принимает объект с { hours, mins, secs }, буквально то что возвращает\n// нам getTimeComponents и обновляет наш элемент clockface через refs.clockface.textContent\n\n// Функция updateClockface принимает время в миллисекундах, Высчитывает сколько в них вмещается часов/минут/секунд, Рисует интерфейс:\n// function updateClockface({ hours, mins, secs }) {\n//   refs.clockface.textContent = `${hours}:${mins}:${secs}`;\n// }\n\n// // Перепишем нашу запись:\n// const timer = {\n//   intervalId: null,\n//   isActive: false, // состояние по умолчанию\n//   start() {\n//     if (this.isActive) {\n//       return;\n//     }\n//     const startTime = Date.now();\n//     this.isActive = true; // если наш isActive в условии if не активный, то присваиваем активный и запускаем интервал\n\n//       this.intervalId = setInterval(() => {\n//         const currentTime = Date.now(); \n//         const deltaTime = currentTime - startTime;\n//         const time = getTimeComponents(deltaTime);\n\n//         // console.log(`${hours}:${mins}:${secs}`); // вместо выведения таймера в консоль, выведем наш таймер в элемент clockface (т.к. в функции\n//         // updateClockface это прописано: refs.clockface.textContent = `${hours}:${mins}:${secs}`):\n//         updateClockface(time); \n//     }, 1000);\n//   },\n//   stop() {\n//     clearInterval(this.intervalId);\n//     this.isActive = false;\n//   }\n// };\n\n// timer.start() // во время вызова этого метода, создается переменная startTime в которой хранится начальное время.\n\n// НО у нас в домашке необходимо написать из этого всего Класс.Плагин это js который натягивается на нашу или чью либо разметку.Но мы сделаем Плагин\n// немного другого типа, тот который предоставлять логику, для этого создадим класс Timer:\n\n// class Timer {\n//   constructor() {\n//     this.intervalId = null;\n//     this.isActive = false;\n//   }\n// // Кроме того нам необходимо включить в наш прототип два метода старт и стоп, мы их писали просто скопируем уже готовые. В будущем это просто будут методы \n// // готового объекта, которые будут лежать не во вне а на прототипе:\n// start() {\n//     if (this.isActive) {\n//       return;\n//     }\n//     const startTime = Date.now();\n//     this.isActive = true;\n\n//       this.intervalId = setInterval(() => {\n//         const currentTime = Date.now(); \n//         const deltaTime = currentTime - startTime;\n//         const time = getTimeComponents(deltaTime);\n\n//         // updateClockface(time); // этот метод на прототипе нам пока не известен, поэтому закомментируем его\n//     }, 1000);\n//   }\n//   stop() {\n//     clearInterval(this.intervalId);\n//     this.isActive = false;\n//   }\n// }\n\n// Наш класс ничего не должен знает про обновление интерфейса, т.е.функция updateClockface(time); ему не доступна, он только умеет подсчитывать.Все остальное,\n// реализовывается на экземпляре, на котором был вызван этот класс (прототип/плагин). Т.е. класс выполняет определенную задачу, все остальные хотелки \n// реализовываются уже на экземпляре. В итоге мы сделали плагин, т.е. класс из которого просто делаются готовые экземпляры, которые в поледствии обвешиваются\n// различным дополнительным функционалом под требование проекта/задачи. \n\n// Ок, просто создадим таймер из готового прототипа(плагина):\n// const timer = new Timer({\n//   // дополним наш экземпляр, который мы создали на основе готового прототипа, доп. настройками, которые будут обновлять наш интерфейс при каждом тике:\n//   onTick: updateClockface\n//   });\n\n// Расширим наш класс доп.свойством для обновления интефейса, т.е. включим в наш прототип все функции которые писали ранее, останется только одна\n// внешняя функция, которая обновляет нам наш интерфейс updateClockface:\n\nclass Timer {\n  constructor({ onTick }) {\n    this.intervalId = null;\n    this.isActive = false;\n    this.onTick = onTick; // деструктуризируем свойство onTick передав его в функцию constructor({onTick})\n\n    this.init(); // добавим в объект настроек новое свойство (показ нулевого счетчика при открытии страницы)\n  }\n\n  // дополним наш класс функционалом: при открытии страницы в нашем интерфейсе будет сразу доступен счетчик с нолями. \n  init() {\n    const time = this.getTimeComponents(0);\n    this.onTick(time);\n  }\n\n  start() {\n    if (this.isActive) {\n      return;\n    }\n\n    const startTime = Date.now();\n    this.isActive = true;\n\n    this.intervalId = setInterval(() => {\n      const currentTime = Date.now();\n      const deltaTime = currentTime - startTime;\n      const time = this.getTimeComponents(deltaTime); // наш класс дополнен методом\n\n      this.onTick(time); // после деструктуризации передадим ссылку на функцию updateClockface, которая обновит нам интерфейс по каждому тику\n    }, 1000);\n  }\n\n  stop() {\n    clearInterval(this.intervalId);\n    this.isActive = false;\n    // дополним нашу функцию стоп: при нажатии на кнопку обнуляется счетчик  \n    const time = this.getTimeComponents(0); \n    this.onTick(time);\n  }\n\n// расширим нашу модель (класс) методами: \n\n// Принимает время в миллисекундах, Высчитывает сколько в них вмещается часов/минут/секунд, Возвращает обьект со свойствами hours, mins, secs, Адская \n// копипаста со стека 💩\n  getTimeComponents(time) {\n    const hours = this.pad(\n      Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),\n    );\n    const mins = this.pad(Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)));\n    const secs = this.pad(Math.floor((time % (1000 * 60)) / 1000));\n\n    return { hours, mins, secs };\n  }\n\n//  Принимает число, приводит к строке и добавляет в начало 0 если число меньше 2-х знаков\n  pad(value) {\n    return String(value).padStart(2, '0');\n  }\n}\n\nconst timer = new Timer({\n  // дополним наш экземпляр, который мы создали на основе готового прототипа, доп. настройками, которые будут обновлять наш интерфейс при каждом тике:\n  onTick: updateClockface\n  });\n\n// Ранее мы повесили слушатели событий на наши кнопки, где заинлайним функцию:\n// refs.startBtn.addEventListener('click', () => { timer.start() }); // слушатель событий с фунцкцией для запуска таймера \n// refs.stopBtn.addEventListener('click', () => { timer.stop() }); // слушатель событий с фунцкцией для остановки таймера\n\n// если хотим передавать колбеком то нашему timer необходимо привязать контекст через .bind(timer):\nrefs.startBtn.addEventListener('click', timer.start.bind(timer));\nrefs.stopBtn.addEventListener('click', timer.stop.bind(timer));\n\nfunction updateClockface({ hours, mins, secs }) {\n  refs.clockface.textContent = `${hours}:${mins}:${secs}`;\n}\n\n// class Timer {\n//   constructor({ onTick }) {\n//     this.intervalId = null;\n//     this.isActive = false;\n//     this.onTick = onTick; // деструктуризируем свойство onTick передав его в функцию constructor({onTick})\n\n//     this.init();\n//   }\n\n//   init() {\n//     const time = this.getTimeComponents(0);\n//     this.onTick(time);\n//   }\n\n//   start() {\n//     if (this.isActive) {\n//       return;\n//     }\n\n//     const startTime = Date.now();\n//     this.isActive = true;\n\n//     this.intervalId = setInterval(() => {\n//       const currentTime = Date.now();\n//       const deltaTime = currentTime - startTime;\n//       const time = this.getTimeComponents(deltaTime);\n\n//       this.onTick(time);\n//     }, 1000);\n//   }\n\n//   stop() {\n//     clearInterval(this.intervalId);\n//     this.isActive = false;\n//     const time = this.getTimeComponents(0);\n//     this.onTick(time);\n//   }\n\n//   /*\n//    * - Принимает время в миллисекундах\n//    * - Высчитывает сколько в них вмещается часов/минут/секунд\n//    * - Возвращает обьект со свойствами hours, mins, secs\n//    * - Адская копипаста со стека 💩\n//    */\n//   getTimeComponents(time) {\n//     const hours = this.pad(\n//       Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),\n//     );\n//     const mins = this.pad(Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)));\n//     const secs = this.pad(Math.floor((time % (1000 * 60)) / 1000));\n\n//     return { hours, mins, secs };\n//   }\n\n//   /*\n//    * Принимает число, приводит к строке и добавляет в начало 0 если число меньше 2-х знаков\n//    */\n//   pad(value) {\n//     return String(value).padStart(2, '0');\n//   }\n// }\n\n// const timer = new Timer({\n//   onTick: updateClockface,\n// });\n\n\n\n\n\n// Перепишем начисто, оригинальный код:\n\n// const refs = {\n//   startBtn: document.querySelector('button[data-action-start]'),\n//   stopBtn: document.querySelector('button[data-action-stop]'),\n//   clockface: document.querySelector('.js-clockface'),\n// };\n\n// class Timer {\n//   constructor({ onTick }) {\n//     this.intervalId = null;\n//     this.isActive = false;\n//     this.onTick = onTick;\n\n//     this.init();\n//   }\n\n//   init() {\n//     const time = this.getTimeComponents(0);\n//     this.onTick(time);\n//   }\n\n//   start() {\n//     if (this.isActive) {\n//       return;\n//     }\n\n//     const startTime = Date.now();\n//     this.isActive = true;\n\n//     this.intervalId = setInterval(() => {\n//       const currentTime = Date.now();\n//       const deltaTime = currentTime - startTime;\n//       const time = this.getTimeComponents(deltaTime);\n\n//       this.onTick(time);\n//     }, 1000);\n//   }\n\n//   stop() {\n//     clearInterval(this.intervalId);\n//     this.isActive = false;\n//     const time = this.getTimeComponents(0);\n//     this.onTick(time);\n//   }\n\n//   /*\n//    * - Принимает время в миллисекундах\n//    * - Высчитывает сколько в них вмещается часов/минут/секунд\n//    * - Возвращает обьект со свойствами hours, mins, secs\n//    * - Адская копипаста со стека 💩\n//    */\n//   getTimeComponents(time) {\n//     const hours = this.pad(\n//       Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),\n//     );\n//     const mins = this.pad(Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)));\n//     const secs = this.pad(Math.floor((time % (1000 * 60)) / 1000));\n\n//     return { hours, mins, secs };\n//   }\n\n//   /*\n//    * Принимает число, приводит к строке и добавляет в начало 0 если число меньше 2-х знаков\n//    */\n//   pad(value) {\n//     return String(value).padStart(2, '0');\n//   }\n// }\n\n// const timer = new Timer({\n//   onTick: updateClockface,\n// });\n\n// refs.startBtn.addEventListener('click', timer.start.bind(timer));\n// refs.stopBtn.addEventListener('click', timer.stop.bind(timer));\n\n// /*\n//  * - Принимает время в миллисекундах\n//  * - Высчитывает сколько в них вмещается часов/минут/секунд\n//  * - Рисует интерфейс\n//  */\n// function updateClockface({ hours, mins, secs }) {\n//   refs.clockface.textContent = `${hours}:${mins}:${secs}`;\n// }\n\n\n"]}