{"version":3,"sources":["js/01-timeout.js"],"names":["logger","time","console","log","timerId","setTimeout","shouldCancelTimer","Math","random","clearTimeout"],"mappings":";;;AAuHA,aAvHA,QAAA,qBA4FA,IAAMA,EAAS,SAAAC,GACbC,QAAQC,IAAiBF,aAAAA,OAAAA,EAAzB,wCAOIG,EAAUC,WAAWL,EAAQ,IAAM,KAKnCM,EAAoBC,KAAKC,SAAW,GAC1CN,QAAQC,IAAIG,GAGRA,GACFG,aAAaL","file":"01-timeout.59b60f27.js","sourceRoot":"../src","sourcesContent":["import '../css/common.css';\n\n// Планировка задач встроена в самом браузере и не есть частью JS\n\n/*\n * Метод window.setTimeout(callback, delay, args) \n */\n\n// setTimeout() позволяет нам зарегистрировать отложенный вызов какой-то функции: принимает три параметра:\n// callback, delay - минимум времени (в мсек) через, который необходимо вызвать функцию, args - аргументы для\n// вызываемой функции.\n\n// На примере:\n// 1.\n// console.log('До вызова setTimeout');\n// // 2.\n// setTimeout(() => {\n//   console.log('Внутри callback для setTimeout');\n// }, 2000);\n// // 3.\n// console.log('После вызова setTimeout');\n\n// Даже если мы в setTimeout(callback, delay, args) на место delay поставим 0, наша функция выполнится 3 - й т.к.setTimeout\n// в любом случае добавляется в планировщик, потом в список отложенных функций и только потом ставится на стек и если\n// есть синхронный код после отложенной функции, то сначала выполнится весь синхронный а только потом из планировщика и \n// списка отложенных функций по очереди вызовутся наши асинхронные функции \n\n// Из примера мы видим, что в первую очередь выполняется запись 1, потом 3, и только потом с задержкой в 2 сек 2-я\n// Очень важно: весь синхронный код выполняется сначала, а только потом выполняются отложенные функции.\n\n// Ещё один примере:\n// 1.\n// console.log('До вызова setTimeout');\n// // 2.\n// setTimeout(() => {\n//   console.log('Внутри callback для setTimeout');\n// }, 2000);\n// // 3.\n// console.log('После вызова setTimeout');\n// // 4.\n// for (let index = 0; index < 10000; index++) {\n//   console.log(index);\n//   }\n\n// В этом примере мы видим что выполнятся опирации в такой последовательности: операция 1, затем зарегистрируется и отложется\n// на 2 секунды операция 2, затем опирация 3 и опреация 4(при этом опирация 4 будет выполняться более чем 2 секунды) и лишь\n// только после того как закончит выполняться операция 4 выполнится операция 2. Получается что пока не отработает синхронный\n// код планировщику не позволят запустить отложенную операцию 2 (отработает как минимум через 2сек, если не будет занято\n// синхронным кодом, если будет занято, то сразу после)\n\n// В примере ниже две отложенные функции, при этом порядок их регистрации не важен, т.к.будет выполняться по времени сразу\n// после синхронного кода, в итоге последовательность выполнения такая: 1, 4, 3, 2\n\n// 1.\n// console.log('До вызова setTimeout');\n\n// 2.\n// setTimeout(() => {\n//   console.log('1 - Внутри callback для setTimeout');\n// }, 2000);\n\n// 3.\n// setTimeout(() => {\n//   console.log('2 - Внутри callback для setTimeout');\n// }, 1000);\n\n// 4.\n// console.log('После вызова setTimeout');\n\n// Как передать аргументы в нашу функцию?:\n\n// setTimeout((х) => {\n//   console.log('2 - Внутри callback для setTimeout');\n// }, 1000, 5);\n\n// Наш х будет равно 5 т.к. мы передали после колбека и делея, аргументом 5, в итоге:\n\n// setTimeout(х => {\n//   console.log(х);\n//   }, 1000, 5);\n\n// т.е.в setTimeout(callback, delay, args) мы передали колбек х, отложенное время 1000 и аргумент для колбека 5,\n// соответстве наш колбек х вызовется через 1 секунду с значением 5.\n\n// Мы рассмотрели как планировать операции в планировщик, теперь рассмотрим как убрать операции из планировщика после того\n// как они стали не нужными:\n\n/*\n * Очистка таймаута с clearTimeout(timeoutId)\n */\n\n// У нас есть функция логер:\nconst logger = time => {\n  console.log(`Лог через ${time}ms, потому что не отменили таймаут`);\n};\n\n// Делаем сет тайм аут для этой функции:\n// setTimeout(logger, 2000, 2000);\n\n// При регистрации каждому таймауту присваивается уникальный идентификатор: \nconst timerId = setTimeout(logger, 2000, 2000);\n\n// console.log(timerId); // в данном случае будет 1\n\n// Пишем переменную с рандомным числом:\nconst shouldCancelTimer = Math.random() > 0.3;\nconsole.log(shouldCancelTimer);\n\n// пишем условие если shouldCancelTimer больше 0.3, то очистить таймаут с указанным идентификатором:\nif (shouldCancelTimer) {\n  clearTimeout(timerId);\n}\n\n// Если true, то происходит очистка таймаута с идентификатором timerId и наш колбек не выполниться, если false, то\n// выполниться колбек функция logger.\n\n// В итоге:\n// setTimeout(callback, delay, args)  - может зпланировать отложенный вызов функции. Позволяет только ОДИН раз вызвать функцию\n// если необходимо вызвать не один раз, то на помощь приходит setInterval (см.далее)\n// clearTimeout(timerId) - может очистить запланированный вызов функции по идентификатору этого таймаута\n\n"]}